
# sample: 012063e0b7b4f7f3ce50574797112f95492772a9b75fc3d0934a91cc60faa240
import re
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from dotnetfile import DotNetPE

# Load the .NET binary file
dotnet_file = DotNetPE("D:\\samples\\sample.bin")

# Get user stream strings from the binary
data = dotnet_file.get_user_stream_strings()

# Define the regular expression pattern to match base64-encoded strings
base64_pattern = r"^(?!.*//)(?=.{20,})(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$"

# Find matches and decrypt them
matches = []

# Define key and iv here
key = bytes(data[-1], 'utf-8')
iv = bytes(data[-1], 'utf-8')

# Dummy decryption function (replace with actual decryption logic)
def decrypt(encrypted, key, iv):
    result = ""
    cipher = AES.new(key, AES.MODE_CBC, iv)
    decrypted_bytes = cipher.decrypt(base64.b64decode(encrypted))
    unpadded_data = unpad(decrypted_bytes, AES.block_size)
    result = unpadded_data.decode('utf-8')
    return result

for value in data:
    if re.search(base64_pattern, value):
        decrypted_text = decrypt(value, key, iv)
        matches.append(decrypted_text)

# Print each element on a new line
for decrypted_text in matches:
    print(decrypted_text)

